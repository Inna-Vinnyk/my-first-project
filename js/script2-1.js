// Рекурсия — это мощный инструмент в программировании, позволяющий функции вызывать саму себя для решения задачи. Это может быть особенно полезно для работы с задачами, которые могут быть разбиты на более мелкие подзадачи. Давайте разберем этот концепт на простых примерах.

// Основные понятия рекурсии
// Базовый случай: Это условие, при котором функция больше не вызывает саму себя. Это важно для предотвращения бесконечной рекурсии.
// Рекурсивный случай: Это часть функции, которая вызывает саму себя с измененными аргументами.

// Пример 1: Факториал числа
// Факториал числа ( n ) (обозначается как ( n! )) — это произведение всех положительных целых чисел от 1 до ( n ). Например:

// ( 5! = 5 \times 4 \times 3 \times 2 \times 1 = 120 )
// ( 0! = 1 ) (по определению)

// Пример 1 Реализации с использованием рекурсии:
// function factorial(n) {
//   // Базовый случай
//   if (n === 0) {
//     return 1; // 0! = 1
//   }
//   // Рекурсивный случай
//   return n * factorial(n - 1); // n! = n * (n-1)!
// }

// console.log(factorial(5)); // Вывод: 120
// console.log(factorial(0)); // Вывод: 1
// Пояснение к коду:
// В функции factorial мы сначала проверяем, является ли ( n ) равным 0. Если да, то возвращаем 1 (это наш базовый случай).
// Если ( n ) больше 0, мы возвращаем произведение ( n ) на результат вызова factorial с аргументом ( n - 1 ). Это и есть рекурсивный случай.

// Пример 2: Числа Фибоначчи
// Последовательность Фибоначчи — это последовательность, в которой каждое число является суммой двух предыдущих. Начинается она с 0 и 1:

// ( F(0) = 0 )
// ( F(1) = 1 )
// ( F(2) = F(1) + F(0) = 1 + 0 = 1 )
// ( F(3) = F(2) + F(1) = 1 + 1 = 2 )
// ( F(4) = F(3) + F(2) = 2 + 1 = 3 )

// Пример 2 Реализации с использованием рекурсии
// function fibonacci(n) {
//     // Базовые случаи
//     if (n === 0) {
//         return 0;
//     }
//     if (n === 1) {
//         return 1;
//     }
//     // Рекурсивный случай
//     return fibonacci(n - 1) + fibonacci(n - 2);
// }

// console.log(fibonacci(5)); // Вывод: 5
// console.log(fibonacci(6)); // Вывод: 8
// Пояснение к коду:
// * Мы определяем базовые случаи для ( n = 0 ) и ( n = 1 ), возвращая 0 и 1 соответственно.
// * В рекурсивном случае мы возвращаем сумму двух предыдущих чисел Фибоначчи.

// Важные моменты:
// 1. Глубина рекурсии: Если функция вызывает саму себя слишком много раз, это может привести к переполнению стека. В JavaScript есть ограничение на глубину рекурсии.
// 2. Эффективность: Рекурсивные решения могут быть менее эффективными, чем итеративные, особенно в случае, как с числами Фибоначчи, где одно и то же значение может вычисляться несколько раз. Для таких случаев может быть полезно использовать мемоизацию.

// Заключение
// Рекурсия — это мощный инструмент, который позволяет решать сложные задачи, разбивая их на более простые подзадачи. Однако важно помнить о базовом случае и следить за глубиной рекурсии, чтобы избежать ошибок. Надеюсь, это объяснение помогло Вам лучше понять рекурсию в JavaScript. Если у Вас есть дополнительные вопросы или Вам нужно больше примеров, не стесняйтесь спрашивать!
